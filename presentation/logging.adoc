== Logging

[%step]
* *Message* +
All data to be logged is transported into `Poco::Message` instances.

* *Logger* +
A logger is the main entry point into the logging framework.

* *Channel* +
A channel has the responsibility to deliver messages to their destination.

* *Formatter* +
A formatter is used to format a message.

[.columns]
=== Message attributes

[.column]
[%step]
* *Priority* +
`PRIO_FATAL` (highest priority), ..., `PRIO_TRACE` (lowest priority).

* *Source* +
Describes the source of a log message (class, subsystem).
Usually set by a Logger to its name.

* *Text* +
The text to be logged.
May be modified by a Formatter before it appears in the destination.

* *Timestamp* +
The date and time the message was created, with up to microsecond precision.
Automatically initialized to the current date and time.

[.column]
[%step]
* *Process and Thread identifier* +
** The Process Identifier (PID), storing the system's process ID.
** The Thread Identifier (TID), storing the serial number of the current thread.
** Additionally, the name of the current thread is stored.

* *Source file and line number*

* *Optional parameters* +
** An arbitrary number of name-value pairs.
** Names and values can be arbitrary strings.
** Message parameters can be referenced in a formatter.

[.columns]
=== Logger

[.column.is-one-third]
[%step]
* *Has a name* +
which becomes the source of all messages generated by that logger.
The name is set upon creation and cannot be changed later.

* *Has an attached Channel* +
which delivers the messages to their destination (possibly, via other channels).

* *Filters messages* +
based on their priority.
Only messages with a priority equal or higher than the logger's log level are propagated.

[.column]
[.fragment]
--
.Example
[source,cpp]
----
#include <Poco/ConsoleChannel.h>
#include <Poco/Logger.h>

int main(int argc, char **argv) {
    using Poco::Logger, Poco::Message;

    auto &logger = Logger::root();               // gets the root logger
    logger.setChannel(new Poco::ConsoleChannel); // attach a channel
    logger.setLevel(Message::PRIO_ERROR);        // sets the log level

    logger.debug("value of a is 2"); <1>
    logger.fatal("cannot allocate memory");

    return 0;
}
----
<1> will not be logged
--

=== Logger Tips&Tricks

[%step]
* Based on their name, loggers form a tree-like hierarchy.

* Te root logger has no name.

* There is no limit on the maximum depth of the logger hierarchy.

* Loggers are dynamically created on demand.

* A newly created logger inherits its log level and attached channel +
from its ancestor.

[.fragment]
--
Several macros are provided as handy shortcuts to optimize performance

[source,cpp]
----
logger.debug(msg); // evaluating message text may be expensive
                   // and will result in a waste of time if logging
                   // level is higher than debug

// a better approach is
poco_debug(logger, msg);

// which is equivalent to
if(logger.debug()) { logger.debug(msg); }
----
--

=== Channel

[%step]
* POCO provides various subclasses of `Poco::Channel` that deliver messages +
to the console, log files or the system's logging facility.

* You can define your own channel classes.

* Channels can be chained by attaching a new channel to an existing one.

* Channels use reference counting for memory management.

* A channel can support an arbitrary number of properties (name-value pairs), +
which are used to configure it.

* Properties can read by calling `getProperty()` method and set by calling +
`setProperty()` method.

=== FormattingChannel and Formatter

[%step]
* `Poco::FormattingChannel` and `Poco::Formatter` are responsible for +
formatting log messages.

* `Poco::FormattingChannel` passes each message it receives through +
a Poco::Formatter, before propagating the message to the next channel.

* `Poco::Formatter` is the base class for all formatter classes.

* `Poco::PatternFormatter` formats messages according to a printf-style pattern.

* Like channels, formatters can be configured using properties.

* Applications built using `Poco::Util::Application` facility can setup +
the logging framework by means of the application configuration file.

* See official documentation https://pocoproject.org/slides/110-Logging.pdf[slides] and
https://pocoproject.org/docs/[reference] for more information.

=== The simplest Channels

[.fragment]
--
.*`ConsoleChannel`* logs to `std::clog`
[source,cpp]
----
#include <Poco/ConsoleChannel.h>
#include <Poco/Logger.h>

int main(int argc, char **argv) {
    auto &logger = Poco::Logger::root();
    logger.setChannel(new Poco::ConsoleChannel);

    logger.information("informative message");

    return 0;
}
----

*`ColorConsoleChannel`* is capable of using ANSI color codes on suppoted terminals
--

[.fragment]
--
.*`SimpleFileChannel`* logs to a file
[source,cpp]
----
#include <Poco/SimpleFileChannel.h>
#include <Poco/Logger.h>

int main(int argc, char **argv) {
    auto &logger = Poco::Logger::root();
    logger.setChannel(new Poco::SimpleFileChannel("messages.log"));

    logger.information("informative message");

    return 0;
}
----

*`FileChannel`* offers a richer set of facilities in terms of rotation, archiving, and purging.
--

=== More advanced Channels

[.fragment]
--
.*`SplitterChannel`* forwards messages to several other destination channels.
[source,cpp]
----
#include <Poco/ConsoleChannel.h>
#include <Poco/SimpleFileChannel.h>
#include <Poco/SplitterChannel.h>
#include <Poco/Logger.h>

int main(int argc, char **argv) {
    auto &logger = Poco::Logger::root();
    auto splitter_channel = new Poco::SplitterChannel;
    splitter_channel->addChannel(new Poco::ConsoleChannel);
    splitter_channel->addChannel(new Poco::SimpleFileChannel("messages.log"));
    logger.setChannel(splitter_channel);
    logger.information("informative message from splitter channel");

    return 0;
}
----
--

[.fragment]
--
.*`AsyncChannel`* decouples the thread producing the log messages from the thread delivering it.
[source,cpp]
----
#include <Poco/AsyncChannel.h>
#include <Poco/ConsoleChannel.h>
#include <Poco/Logger.h>
#include <Poco/ThreadPool.h>

int main(int argc, char **argv) {
    auto &logger = Poco::Logger::root();
    logger.setChannel(new Poco::AsyncChannel(new Poco::ConsoleChannel));

    logger.information("informative async message");

    Poco::ThreadPool::defaultPool().joinAll(); // UB is guaranteed if removed!

    return 0;
}
----
--

=== And finally...

[.fragment]
--
.*`SyslogChannel`* forwards messages to local Syslog daemon (UNIX only).
[source,cpp]
----
#include <Poco/SyslogChannel.h>
#include <Poco/Logger.h>

int main(int argc, char **argv) {
    auto &logger = Poco::Logger::root();
    logger.setChannel(new Poco::SyslogChannel);

    logger.error("error message from a user application");

    return 0;
}
----

The *Net* library offers the *`RemoteSyslogChannel`* that works with remote Syslog daemons.
--

[.fragment]
--
.*`EventChannel`* signals every message flows through it.
[source,cpp]
----
#include <Poco/EventChannel.h>
#include <Poco/FunctionDelegate.h>
#include <Poco/Logger.h>

int main(int argc, char **argv) {
    auto event_channel = new Poco::EventChannel;

    event_channel->messageLogged += Poco::FunctionDelegate<const Poco::Message>(
        [](const void *, const auto &msg) { std::cout << "got message: " << msg.getText() << '\n'; });

    Poco::Logger::root().setChannel(event_channel);
    Poco::Logger::root().information("informative message");

    return 0;
}
----
--

=== FormattingChannel in action

[.fragment]
--
.*`FormattingChannel`* needs a *`PatternFormatter`* to work properly.
[source,cpp]
----
#include <Poco/ConsoleChannel.h>
#include <Poco/FormattingChannel.h>
#include <Poco/PatternFormatter.h>
#include <Poco/Logger.h>

int main(int argc, char **argv) {
    auto &logger = Poco::Logger::get("SampleApp");
    auto pattern = new Poco::PatternFormatter("%L%Y-%m-%d %H:%M:%S.%F -%q- [%s] %t");
    auto formatting_channel = new Poco::FormattingChannel(pattern);
    formatting_channel->setChannel(new Poco::ConsoleChannel);
    logger.setChannel(formatting_channel);
    logger.information("a formatted informative message");

    return 0;
}
----
--
